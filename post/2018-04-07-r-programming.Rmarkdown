---
title: R Programming
author: jonthelaion
date: '2018-04-25 18:00:00'
slug: r-programming
categories:
  - R
  - coursera
  - mooc
tags:
  - R
  - coursera
  - mooc
---

# R Basics

R has five basic/atomic classes of objects:

- character
- numeric (real numbers)
- integer
- complex
- logical (True/False)

R objects have attributes and can be accessed by using the `attributes()` function.

**Numerics** are generally treated as double precision real numbers.

**Integers** are obtained by specifying the `L` suffix (e.g. `1L`).

There is also a special number `Inf` which represents infinity and `NaN` represents an undefined value.

# Vectors

- **Vectors** can be created with either `c()` or `vector()`.

```{r}
# c() is commonly used to create vectors.
v1 <- c(1,2,3)
v1
```

```{r}
# vector() function can be used to initialise vectors.
v2 <- vector("numeric", length = 10)
v2
```

- A vector can only contain objects of the same class.
- If different classes are mixed together, they will be coerced so that every element is the same class.
- Explicit coercion can be fored by using the `as.*()` functions (e.g. `as.character()`).

# Matrices

- **Matrices** are vectors with a dimension attribute that are constructed column-wise by default.

```{r}
print(m1 <- matrix(1:6, nrow=2, ncol=3))
print(dim(m1))
print(attributes(m1))
```

- Matrices can also be created directly from vectors by adding a dimension attribute.

```{r}
m2 <- 1:10
dim(m2) <- c(2,5)
m2
```

- Matrices can also be created by using `cbind()` and `rbind()`.

```{r}
x <- 1:3
y <- 10:12
cbind(x,y)
rbind(x,y)
```

# Lists

**Lists** can contain different class types.

```{r}
print(l1 <- list(1, 'a', TRUE, 1+4i))
```

# Factors

- Factors are used to represent cateogrical data.
- Factors can be unordered or ordered.
- One can think of a factor as an integer vector where each integer has a label.
- Factors are treaded specially by modelling functions like `lm()` and `glm()`.
- The order of the levels can be set using the levels argument to `factor()`. This can be important in linear modelling because the first level is used as the baseline level.
- Using gactors with labels is better than using integers because factors are self-describing; having a variable that has values `'Male'` and `'Female'` is better than a variable that has values `1` or `2`.

```{r}
x <- factor(c("Yes","Yes","No","Yes","No"))
x
table(x)
unclass(x)
levels(x)
```

# Data Frames

- Data frames are used to store tabular data.
- They are represented as a special type of list where every element of the list has to have the same length.
- Each element of the list can be though of as a column and the length of each element of the list is the number of rows.
- Unlike matrices, data frames can store different classes of objects in each column. Matrices must have every element to be the same class.
- Data frames are usually created by reading some external data into R by using `read.table()` or `read.csv()`.
- `data.frame()`: To manually create a data frame.
- `row.names()`: To get the names of the row index.
- `names()`: To get the names of the column index.
- `data.matrix()`: To convert a data frame to a matrix.

```{r}
df <- data.frame(foo = 1:4, bar = c(T, T, F, F))
df
row.names(df)
names(df)
```

# Names

- R objects can also have names, which is very useful for writing readable code and self-describing objects.

`names()` with vector

```{r}
x <- 1:3
names(x)
names(x) <- c('foo', 'bar', 'norf')
names(x)
```

`names()` with matrix

```{r}
m <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(m) <- list(c('a','b'), c('c','d'))
m
```

`names()` with list

```{r}
l <- list('a' = 1, 'b' = 2, 'c' = 3)
l
```


# Missing Values

- Missing values are denoted by `NA` or `NaN` for undefined mathematical operations.
- `is.na()` is used to test objects if they are `NA`.
- `is.nan()` is used to test for `NaN`.

# Programming with R

## Control Structures
Control structures allow you to control the flow of execution of the program:

- If/Else: testing a condition
- For: execute a loop a fixed number of times
- While: execute a loop while a condition remains true
- Repeat: execute an infinite loop
- Break: break the execution of a loop
- Next: skip an iteration of a loop
- Return: exit a function
- Most control structures are not used in interactive sessions, but rather when writing functions or longer expressions.

## If/Else

The general syntax is as follows:

```{r}
#if(<condition_1>){
#<do_something>
#}else if(condition_2){
#<do_something_else>
#}else{
#<do_something_else>
#}
```

Assignments can be performed inside the If/Else construct or outside.

## For Loops

```{r}
for(i in 1:5){
print(i)
}
```

- `seq_along(<vector>)` takes any vector and creates an integer vector equal to `1:length(<vector>)`.
- Index variable can be other objects (e.g. `for(letter in x)`)
- If the For Loop only has a single expression, can take out the curly braces and put it one line depending on stylistic preferences
- For loops can be nested (e.g. for matrix)
- `for(l in seq_len(nrow(x)))` creates an integer vector

## While Loops

```{r}
count <- 0
while(count < 5){
    print(count)
    count <- count + 1
}
```

- While loops begin by testing a condition. If it is true, then the loop body is executed. Once the loop body is executed, the condition is tested again, and so forth.
- Sometimes there will be more than one condition in the test.
- Conditions are always evaluated left to right.

## User-Defined Functions

Functions in R have the following general syntax:

```{r}
# myfunction <- function(argument1, argument2, ...){
#     statements
#     return(object)
# }
```

An example of a simple function to find the hypotenuse of a right-angled triangle given the other two sides, `a` and `b`:

```{r}
hypotenuse <- function(a, b){
    hyp <- sqrt(a^2 + b^2)
    return(hyp)
}

hypotenuse(3, 4)
```

# Simulation and Profiling

## The str Function

- `str()`: compactly displays the internal structure of an R object.
- Can think of it as meaning structure.
- A diagnostic function and an alternative to `summary()`.
- It is especially well suited to compactly display the (abbreviated) contents of (possibly nested) lists.
- Roughly one line per object.

## Simulation

- Functions for probability distributions in R:
 - `Rnorm()`: generate randomal normal variates with a given mean and standard deviation